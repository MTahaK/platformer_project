diff --git a/game b/game
index 207ae2e..44a40e7 100755
Binary files a/game and b/game differ
diff --git a/include/physics.hpp b/include/physics.hpp
index 1fb9faa..3fba7fc 100644
--- a/include/physics.hpp
+++ b/include/physics.hpp
@@ -13,8 +13,8 @@ const float gravity = -8.0f;
 const float MAX_VELOCITY = 10.0f; // Maximum velocity limit
 
 const float movementAccel = 6.0f; // Acceleration applied when moving left/right
-const float slowdownAccel = 14.0f; // Acceleration applied when slowing down
-const float turnaroundAccel = 16.0f;
+const float slowdownAccel = 16.0f; // Acceleration applied when slowing down
+const float turnaroundAccel = 18.0f;
 const float midairDrag = 1.0f;
 
 class Physics {
diff --git a/include/playerobject.hpp b/include/playerobject.hpp
index dfa53e0..5d2ca30 100644
--- a/include/playerobject.hpp
+++ b/include/playerobject.hpp
@@ -16,7 +16,12 @@ class PlayerObject : public GameObject {
         void setUpSensors();
         void sensorUpdate();
 
+        void setGoalCount(int count) { goal_count = count; } // Set the goal count
+        void incrementGoalCount() { goal_count++; } // Increment the goal count
+
+
         bool tileCollision(Tilemap& tilemap, const Sensor& sensor);
+        bool tileGoalCollision(Tilemap& tilemap, const Sensor& sensor);
         // Getters for sensors
         // const Sensor& getASensor() const { return ASensor; }
         // const Sensor& getBSensor() const { return BSensor; }
@@ -26,6 +31,9 @@ class PlayerObject : public GameObject {
         // const Sensor& getESensor() const { return ESensor; }
         // const Sensor& getFSensor() const { return FSensor; }
 
+        const glm::ivec2 getPlayerTileIdx(Tilemap& tilemap) const;
+        int getGoalCount() const { return goal_count; }
+
         const Sensor& getLeftSensor() const { return leftSensor; }
         const Sensor& getRightSensor() const { return rightSensor; }
         const Sensor& getTopSensor() const { return topSensor; }
@@ -54,4 +62,6 @@ class PlayerObject : public GameObject {
         Sensor topSensor;    // Top sensor for detecting ceilings
         Sensor bottomSensor; // Bottom sensor for detecting floors
 
+        int goal_count = 0; // Counter for the number of sensors that detect a goal tile
+
 };
\ No newline at end of file
diff --git a/include/tilemap.hpp b/include/tilemap.hpp
index 4467b2f..9beb183 100644
--- a/include/tilemap.hpp
+++ b/include/tilemap.hpp
@@ -38,6 +38,7 @@ class Tilemap {
         glm::ivec2 getInitPlayerPos() { return playerpos_; }
         glm::ivec2 getGoalPos() { return goalpos_; }
         bool isSolidTile(int x, int y); // Check if the tile at (x, y) is solid
+        bool isGoalTile(int x, int y);  // Check if the tile at (x, y) is a goal tile
 
         // Setters
         void setTile(int x, int y, const TileType& tileType); // Set tile at position (x, y) with a specific type
diff --git a/src/physics.cpp b/src/physics.cpp
index 5010bf0..4b4a612 100644
--- a/src/physics.cpp
+++ b/src/physics.cpp
@@ -50,6 +50,38 @@ void Physics::checkPlayerWorldCollisions(PlayerObject& player, Tilemap& tilemap)
 
     // ! NOTE: TILE STRUCT POSITION STARTS AT BOTTOM LEFT CORNER, NOT CENTER
 
+    // Goal-collision optimisation
+    // ---------------------------
+    // We skip expensive “all-sensor” checks until the player is very close to a goal:
+    //   • Proximity filter: Chebyshev distance (tile units) ≤ 1 to *any* goal tile.
+    //   • Precision check: when that filter passes, probe each of the four sensors.
+    //     A probe is just a tile lookup, so the per-frame cost is O(1) (4 lookups).
+    //
+    // Rationale: sensor probes, while cheap, still add measurable overhead if run
+    // every frame across the whole map. In our current level layouts goal tiles are
+    // either clustered or aligned along one axis, so a single distance test is
+    // enough to gate the precise checks.
+
+
+    // Proximity filter: Chebyshev distance (tile units) ≤ 1 to *any* goal tile.
+    glm::ivec2 playerTile = tilemap.worldToTileIndex(player.getPosition());
+    glm::ivec2 goalTile = tilemap.getGoalPos();
+    int goalDistance = std::max(std::abs(playerTile.x - goalTile.x), std::abs(playerTile.y - goalTile.y));
+
+    if(goalDistance <= 1){
+        if(player.tileGoalCollision(tilemap, player.getLeftSensor()) ||
+        player.tileGoalCollision(tilemap, player.getRightSensor()) ||
+        player.tileGoalCollision(tilemap, player.getTopSensor()) ||
+        player.tileGoalCollision(tilemap, player.getBottomSensor())) {
+            // If any sensor collides with a goal tile, increment goal count
+            if(player.getGoalCount() == 4){
+                // If all sensors have collided with a goal tile, the player has reached the goal
+                player.setGoalCount(0); // Reset goal count
+                player.setPosition(tilemap.tileIndexToWorldPos(tilemap.getInitPlayerPos().x, tilemap.getInitPlayerPos().y)); // Reset player position to initial
+                DEBUG_ONLY(std::cout<<"Player has reached the goal! Resetting position to initial.\n";);
+            }
+        }
+    }
     // Check collisions with the tilemap using sensors
     if(player.getVelocity().x < 0.0f){
         // Negative velocity, don't need to check right sensor
diff --git a/src/playerobject.cpp b/src/playerobject.cpp
index 44074dd..5315b9e 100644
--- a/src/playerobject.cpp
+++ b/src/playerobject.cpp
@@ -58,13 +58,32 @@ void PlayerObject::sensorUpdate() {
     
 }
 
+const glm::ivec2 PlayerObject::getPlayerTileIdx(Tilemap& tilemap) const {
+    return tilemap.worldToTileIndex(getPosition());
+}
+
 bool PlayerObject::tileCollision(Tilemap& tilemap, const Sensor& sensor) {
-    glm::ivec2 tileIndex = tilemap.worldToTileIndex(sensor.position);
+    glm::ivec2 tileIndex = getPlayerTileIdx(tilemap);
     bool isSolid = tilemap.isSolidTile(tileIndex.x, tileIndex.y);
     return isSolid; // Check if the tile at the sensor's position is solid
     // return tilemap.isSolidTile(tileIndex.x, tileIndex.y);
 }
 
+bool PlayerObject::tileGoalCollision(Tilemap& tilemap, const Sensor& sensor) {
+    glm::ivec2 tileIndex = getPlayerTileIdx(tilemap);
+    bool isGoal = tilemap.isGoalTile(tileIndex.x, tileIndex.y);
+    if(isGoal){
+        goal_count++;
+    } else if(goal_count > 0) {
+        goal_count--; // Decrease goal count if the player is not on a goal tile
+    } else if (goal_count < 0) {
+        goal_count = 0; // Ensure goal count does not go negative
+    } else{
+        goal_count = 0; // Reset goal count if the player is not on a goal tile
+    }
+    return isGoal; // Check if the tile at the sensor's position is a goal tile
+}
+
 bool PlayerObject::checkIfWin(Tilemap& tilemap){
     auto playeridx = tilemap.worldToTileIndex(getPosition());
     
diff --git a/src/tilemap.cpp b/src/tilemap.cpp
index e60576b..83732f1 100644
--- a/src/tilemap.cpp
+++ b/src/tilemap.cpp
@@ -23,6 +23,11 @@ bool Tilemap::isSolidTile(int x, int y) {
     return tiles[y][x].tileType.type == TileEnum::SOLID;
 }
 
+bool Tilemap::isGoalTile(int x, int y) {
+    if (x < 0 || x >= width_ || y < 0 || y >= height_) return false;
+    return tiles[y][x].tileType.type == TileEnum::GOAL;
+}
+
 void Tilemap::setTile(int x, int y, const TileType& tileType) {
     if (x < 0 || x >= width_ || y < 0 || y >= height_) return;
     tiles[y][x].tileType = tileType;
